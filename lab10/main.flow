import lingo/pegcode/driver;
import ds/tree;

ArExpr ::= ArInt, ArVar, ArMinus, ArBinary;

ArBinary ::= ArMult, ArSum, ArDiv, ArSub;
ArSum(lhs : ArExpr, rhs : ArExpr);
ArMult(lhs : ArExpr, rhs : ArExpr);
ArSub(lhs : ArExpr, rhs : ArExpr);
ArDiv(lhs : ArExpr, rhs : ArExpr);


ArMinus(num : ArNum);
ArNum ::= ArInt, ArVar;
ArVar(var : string);
ArInt(val : int);

ArMonom(mult : Tree<string, int>);
ArPolynom(sum : Tree<ArMonom, int>);

ArRatFunc(num : ArPolynom, den : ArPolynom);

// rational number
ArRat(num : int, den : int);

NaN = ArInt(0);

ar2s(expr : ArExpr) -> string {
    switch(expr : ArExpr) {
        ArSum(lhs, rhs) :  "(" + ar2s(lhs) + " + " + ar2s(rhs) + ")";
        ArMult(lhs, rhs) : "(" + ar2s(lhs) + " * " + ar2s(rhs) + ")";
        ArSub(lhs, rhs) : "(" + ar2s(lhs) + " - " + ar2s(rhs) + ")";
        ArDiv(lhs, rhs) : "(" + ar2s(lhs) + " / " + ar2s(rhs) + ")";
        ArInt(var) : i2s(var);
		ArVar(var) : var;
		ArMinus(num) : "-" + ar2s(num);
    }
}


s2ar(str : string) -> ArExpr {
    e_gr = "#include extended_grammar.lingo";
    parsic(compilePegGrammar(e_gr),
			str,
			defaultPegActions
          )
}

MatchInfo(match: bool, varRes: Tree<ArVar, ArExpr>);

NOT_MATCH = MatchInfo(false, makeTree());

makeRules(rulesArr: [Pair<string, string>]) -> Tree<ArExpr, ArExpr> {
    foldi(rulesArr, makeTree(), \i, acc, rule -> {
        exprLong = s2ar(rule.first);
        exprShort = s2ar(rule.second);
        setTree(acc, exprLong, exprShort);
    });
}

inlineVariables(ex : ArExpr, varResolve: Tree<ArVar, ArExpr>) -> ArExpr {
    switch(ex) {
        ArInt(val): ex; 

        ArVar(name): {
            resolve = lookupTreeDef(varResolve, ex, NaN);
            if (resolve == NaN) {
                ex;
            } else {
                resolve;
            }
        }

        ArMinus(arg) : {
			var = inlineVariables(arg, varResolve);

			switch(var) {
				ArInt(i) : ArMinus(ArInt(i));
				ArVar(v) : ArMinus(ArVar(v));
				default : {
					//	println("Unexpected type, expected int or var, but got: " + var.name);
					// never used
					ArMinus(ArInt(1));
				}
			}
		}
		
        ArSum(left, right): { 
			ArSum(inlineVariables(left, varResolve), inlineVariables(right, varResolve));
		}
        ArSub(left, right): { 
			ArSub(inlineVariables(left, varResolve), inlineVariables(right, varResolve));
		}
        ArDiv(left, right): { 
			ArDiv(inlineVariables(left, varResolve), inlineVariables(right, varResolve));
		}
        ArMult(left, right): { 
			ArMult(inlineVariables(left, varResolve), inlineVariables(right, varResolve));
		}
    }
}

match(template: ArExpr, ex: ArExpr, varRes: Tree<ArVar, ArExpr>) -> MatchInfo {
    // println(exprToStr(ex) + " by template " + exprToStr(template));
    switch(template) {
        ArInt(i): {
            switch(ex) {
                ArInt(i1): {
                    MatchInfo(template == ex, varRes);
                }
                default: NOT_MATCH;
            }
        }

        ArVar(name): {
            curVal = lookupTreeDef(varRes, template, NaN);
            if (curVal == NaN) {
                MatchInfo(true, setTree(varRes, template, ex));
            } else {
                if (curVal == ex) {
                    MatchInfo(true, varRes);
                } else {
                    // println(exprToStr(curVal) + " != " + exprToStr(ex));
                    NOT_MATCH;
                }
            }
        }

        ArMinus(arg): {
            switch(ex) {
                ArMinus(arg2): match(arg, arg2, varRes);
                default: NOT_MATCH;
            }
        }

		ArSum(left, right) : {
            switch(ex) {
                ArSum(left2, right2) : {
                        matchLL = match(left, left2, varRes);
                        matchRR = match(right, right2, matchLL.varRes);

                        if (matchLL.match && matchRR.match) {
                            MatchInfo(true, matchRR.varRes);
                        } else {
                            NOT_MATCH;
                        }
                    } 
				default: NOT_MATCH;
            }
		}

		ArSub(left, right) : {
            switch(ex) {
                ArSub(left2, right2) : {
					matchLL = match(left, left2, varRes);
                    matchRR = match(right, right2, matchLL.varRes);

                    if (matchLL.match && matchRR.match) {
                        MatchInfo(true, matchRR.varRes);
                    } else {
                        NOT_MATCH;
                    }
                } 
				default: NOT_MATCH;
			}
		}

		ArMult(left, right) : {
            switch(ex) {
                ArMult(left2, right2) : {
					matchLL = match(left, left2, varRes);
                    matchRR = match(right, right2, matchLL.varRes);

                    if (matchLL.match && matchRR.match) {
                        MatchInfo(true, matchRR.varRes);
                    } else {
                        NOT_MATCH;
                    }
                } 
				default: NOT_MATCH;
			}
		}

		ArDiv(left, right) : {
            switch(ex) {
                ArDiv(left2, right2) : {
					matchLL = match(left, left2, varRes);
                    matchRR = match(right, right2, matchLL.varRes);

                    if (matchLL.match && matchRR.match) {
                        MatchInfo(true, matchRR.varRes);
                    } else {
                        NOT_MATCH;
                    }
                } 
				default: NOT_MATCH;
			}
		}
	}
}

reduceOnce(ex : ArExpr, rules : Tree<ArExpr, ArExpr>) -> ArExpr {

    res = ex;

    res2 = switch(res) {
		ArInt(val) : res;
		ArVar(var) : res;
		ArMinus(arg) : {
			var = reduceOnce(arg, rules);
			switch(var) {
				ArInt(i) : ArMinus(ArInt(i));
				ArVar(v) : ArMinus(ArVar(v));
				default : {
					// println("Unexpected type, expected int or var, but got: " + var.name);
					ArMinus(ArInt(1));
				}
			}
		}

		ArSum(left, right) : ArSum(reduceOnce(left, rules), reduceOnce(right, rules));
		ArSub(left, right) : ArSub(reduceOnce(left, rules), reduceOnce(right, rules));
		ArDiv(left, right) : ArDiv(reduceOnce(left, rules), reduceOnce(right, rules));
		ArMult(left, right) : ArMult(reduceOnce(left, rules), reduceOnce(right, rules));
    }

    foldTree(rules, res2, \rule, value, acc -> {
		mInfo = match(rule, acc, makeTree());
		if (mInfo.match) {
			inlineVariables(value, mInfo.varRes);
		} else {
			acc;
		}
    });
}


reduce(ex : ArExpr, rules : Tree<ArExpr, ArExpr>) -> ArExpr {
    reduced = reduceOnce(ex, rules);

	if (reduced == ex) {
		reduced;
	} else {
		reduce(reduced, rules);
	}
}

main() {
    rulesArr = [
                Pair("(x - x)", "(0)"),
				Pair("(x / x)", "(1)"),
                Pair("(x + x)", "(2 * x)"),
                Pair("((y * x) + (z * x))", "((y + z) * x)"),
                Pair("(0 * x)", "(0)"),
                Pair("(x + 0)", "(x)"),
                Pair("(x * 1)", "(v)")
    ];

    rules = makeRules(rulesArr);

    examples = [
        "((4 * x) + (5 * x))",
        "(((3 * x) + 7) + (7 + (3 * x)))",
		"((x - y) * (x + y))",
		"(((x + x) + x) / ((x + x) + x))"
    ];

    iter(examples, \example -> {
        ex = s2ar(example);
        exs = reduce(ex, rules);
        println("before: " + example);
        println("after:  " + ar2s(exs));
        println("");
    });
}
