import lingo/pegcode/driver;
import runtime;
import lib/sys/system;

ArExpr ::= ArSum, ArMult, ArSub, ArDiv, ArInt, ArVar, ArMinus;

ArNum ::= ArInt, ArVar;

ArSum(lhs : ArExpr, rhs : ArExpr);
ArMult(lhs : ArExpr, rhs : ArExpr);
ArSub(lhs : ArExpr, rhs : ArExpr);
ArDiv(lhs : ArExpr, rhs : ArExpr);
ArVar(var : string);
ArInt(val : int);
ArMinus(num : ArNum);

// rational number
ArRat(num : int, den : int);

//     +
//   /  \ 
//  /    \
// ArNum 0

// ArNum

s2ar(str : string) -> ArExpr {
    e_gr = "#include extended_grammar.lingo";
    parsic(compilePegGrammar(e_gr),
			str,
            SemanticActions(setTree(defaultPegActions.t,
                    "createArInt", \s -> ArInt(s2i(s[0]))))
          )
}

// -a / -b -> a / b
// a / -b -> -a / b
get_numerator(a : int, b : int) -> int {
	if (a < 0 && b < 0) {-a;}

	else if (a > 0 && b < 0) {-a;}

	else {a;}
}

get_denominator(a : int, b : int) -> int {
	if (a < 0 && b < 0) {-b;}

	else if (a > 0 && b < 0) {-b;}

	else {b;}
}

simplify_fract(numerator : int, denominator : int) -> Maybe<ArRat> {
	if (denominator == 0) {
		None();
	}
	else {
		// -a / -b -> a / b
		// a / -b -> -a / b
		num = get_numerator(numerator, denominator);
		den = get_denominator(numerator, denominator);

		nod : int = NOD(num, den);
		Some(ArRat(num / nod, den / nod));
	}
}

NOD(numerator : int, denominator : int) -> int {
	if (numerator == 0) { 1; }

	else {
		abs_num : int = iabs(numerator);

		if (abs_num == denominator) {
			abs_num;
		}
		
		else if (abs_num > denominator) {
			NOD(abs_num - denominator, denominator);
		}

		else {
			NOD(abs_num, denominator - abs_num);
		}
	}
}

get_var(numerator : int, denominator : int) -> Maybe<ArRat> {
	if (denominator <= 0) {
		None();
	}
	else {
		simplify_fract(numerator, denominator);
	}
}

handle_var(var : string) -> Maybe<ArRat> {

	print("Input variable ");
	println(var);

	print("numerator = ");
	numerator : int = s2i(readUntil("\n"));

	print("denominator = ");
	denominator : int = s2i(readUntil("\n"));
	
	get_var(numerator, denominator);
}

apply(lhs : Maybe<ArRat>,
	  rhs : Maybe<ArRat>, 
	  func : (l : ArRat, r : ArRat) -> Maybe<ArRat>) -> Maybe<ArRat> {

	switch(lhs) {
		None() : None();
		Some(l) : {
			switch(rhs) {
				None() : None();
				Some(r) : {
					func(l, r);
				}
			}
		}
	}
}

// if x == 0 return y
// if y == 0 return x
simplify_sum(x : ArExpr, y : ArExpr) -> ArExpr {
	if (x.structname == "ArInt" && x.val == 0) { y; }
	else if (y.structname == "ArInt" &&  y.val == 0) { x; }
	else ArSum(x, y);
}

simplify_mult(x : ArExpr, y : ArExpr) -> ArExpr {
	switch (x) {
		ArInt(x_val) {
			if (x.val == 1) { y; }
			else { 
				switch (y) {
					ArInt(y_val) {
						if (y.val == 1) { x; }
						else ArMult(x, y);
					}
					ArSum(lhs, rhs) : ArMult(x, y);
					ArDiv(lhs, rhs) : ArMult(x, y); 
					ArMult(lhs, rhs) : ArMult(x, y); 
					ArSub(lhs, rhs) : ArMult(x, y); 
					ArVar(val) : ArMult(x, y);
					ArMinus(val) : ArMult(x, y);
				}
			}
		}

		default : {
			switch (y) {
				ArInt(y_val) {
					if (y.val == 1) { x; }
					else ArMult(x, y);
				}
				ArSum(lhs, rhs) : ArMult(x, y); 
				ArDiv(lhs, rhs) : ArMult(x, y); 
				ArMult(lhs, rhs) : ArMult(x, y); 
				ArSub(lhs, rhs) : ArMult(x, y); 
				ArVar(val) : ArMult(x, y);
				ArMinus(val) : ArMult(x, y);
			}
		}
	}
}

arith_simplify(expr : ArExpr) -> ArExpr {
	switch(expr) {
		ArSum(lhs, rhs) : simplify_sum(arith_simplify(lhs), arith_simplify(rhs));

		ArMult(lhs, rhs) : simplify_mult(arith_simplify(lhs), arith_simplify(rhs));

		ArSub(lhs, rhs) : simplify_sum(arith_simplify(lhs), arith_simplify(rhs));

		ArDiv(lhs, rhs) : ArDiv(lhs, rhs);

		ArVar(var) : ArVar(var);

		ArMinus(num) : ArMinus(num);

		ArInt(val) : ArInt(val);
	}
}

calculate(expr : ArExpr) -> Maybe<ArRat> {
    switch(expr : ArExpr) {
        ArSum(lhs, rhs) : apply(calculate(lhs),
								calculate(rhs),
								\x, y -> simplify_fract(x.num * y.den + x.den * y.num, x.den * y.den));

        ArMult(lhs, rhs) : apply(calculate(lhs),
								 calculate(rhs),
								 \x, y -> simplify_fract(x.num * y.num, x.den * y.den));

        ArSub(lhs, rhs) : apply(calculate(lhs),
								calculate(rhs),
								\x, y -> simplify_fract(x.num * y.den - x.den * y.num, x.den * y.den));

        ArDiv(lhs, rhs) : apply(calculate(lhs),
								calculate(rhs),
								\x, y -> simplify_fract(x.num * y.den, x.den * y.num));

		ArVar(var) : handle_var(var);

		ArMinus(num) : {
			switch (num) {
				ArInt(val) : Some(ArRat(-val, 1));
				ArVar(var) : {
					rat : Maybe<ArRat> = handle_var(var);
					switch (rat) {
						None() : None();
						Some(v) : Some(ArRat(-v.num, v.den));
					}
				}
			}
		}

        ArInt(var) : {
			Some(ArRat(var, 1));
		}
    }
}

printArRat(fract : Maybe<ArRat>) -> void {
	switch (fract) {
		None() : println(None());
		Some(val) : {
			if (val.den == 1) {
				println(i2s(val.num));
			}
			else if (val.num == 0) {
				println("0");
			}
			else {
				println(i2s(val.num) + " / " + i2s(val.den));
			}
		}
	}
}


ar2s(expr : ArExpr) -> string {
    switch(expr : ArExpr) {
        ArSum(lhs, rhs) :  "(" + ar2s(lhs) + "+" + ar2s(rhs) + ")";
        ArMult(lhs, rhs) : "(" + ar2s(lhs) + "*" + ar2s(rhs) + ")";
        ArSub(lhs, rhs) : "(" + ar2s(lhs) + "-" + ar2s(rhs) + ")";
        ArDiv(lhs, rhs) : "(" + ar2s(lhs) + "/" + ar2s(rhs) + ")";
        ArInt(var) : i2s(var);
		ArVar(var) : var;
		ArMinus(num) : ar2s(num);
    }
}


main() {
	example = "(1 + 0)";
	println(s2ar(example));
	println(ar2s(s2ar(example)));
//	printArRat(calculate(s2ar(example)));
}

// a = 0 / 3; b = 0 / 3 -> None
// a = 1 / 2; b = 0 / 3 -> None
// a = -1 / 2; b = -1 / 2 -> 1
// example = "(a / b)";



